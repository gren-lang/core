module String.Parser.Advanced exposing
  ( Parser, run, DeadEnd, inContext, Token
  , int, token, keyword, variable, end
  , succeed, keep, skip, lazy, andThen, problem
  , oneOf, map, mapError, backtrackable, commit 
  , sequence, Trailing(..), loop, Step(..)
  , spaces, lineComment, multiComment, Nestable(..)
  , getChompedString, chompIf, chompWhile, chompUntil, chompUntilEndOr, mapChompedString
  , withIndent, getIndent
  , getPosition, getRow, getCol, getOffset, getSource
  )


{-|

# Parsers
@docs Parser, run, DeadEnd, inContext, Token

* * *
**Everything past here works just like in the
[`Parser`](/package/gren-lang/parser/latest/Parser) module, except that `String`
arguments become `Token` arguments, and you need to provide a `Problem` for
certain scenarios.**
* * *

# Building Blocks
@docs int, token, keyword, variable, end

# Pipelines
@docs succeed, keep, skip, lazy, andThen, problem

# Branches
@docs oneOf, map, mapError, backtrackable, commit 

# Loops
@docs sequence, Trailing, loop, Step

# Whitespace
@docs spaces, lineComment, multiComment, Nestable

# Chompers
@docs getChompedString, chompIf, chompWhile, chompUntil, chompUntilEndOr, mapChompedString

# Indentation
@docs withIndent, getIndent

# Positions
@docs getPosition, getRow, getCol, getOffset, getSource
-}


import Basics exposing (..)
import String exposing (String)
import Array exposing (Array)
import Char exposing (Char)
import Set
import Result exposing (Result(..))
import Maybe exposing (Maybe(..))



-- PARSERS


{-| An advanced `Parser` gives two ways to improve your error messages:

- `problem` &mdash; Instead of all errors being a `String`, you can create a
custom type like `type Problem = BadIndent | BadKeyword String` and track
problems much more precisely.
- `context` &mdash; Error messages can be further improved when precise
problems are paired with information about where you ran into trouble. By
tracking the context, instead of saying “I found a bad keyword” you can say
“I found a bad keyword when parsing a list” and give folks a better idea of
what the parser thinks it is doing.

I recommend starting with the simpler [`Parser`][parser] module though, and
when you feel comfortable and want better error messages, you can create a type
alias like this:

```gren
import Parser.Advanced

type alias MyParser a =
  Parser.Advanced.Parser Context Problem a

type Context = Definition String | List | Record

type Problem = BadIndent | BadKeyword String
```

All of the functions from `Parser` should exist in `Parser.Advanced` in some
form, allowing you to switch over pretty easily.

[parser]: /package/gren-lang/parser/latest/Parser
-}
type Parser context problem value =
  Parser (State context -> PStep context problem value)


type PStep context problem value
  = Good { pred : Bool, value : value, state : (State context) }
  | Bad { pred : Bool, bag : (Bag context problem) }


type alias State context =
  { src : String
  , offset : Int
  , indent : Int
  , context : Array (Located context)
  , row : Int
  , col : Int
  }


type alias Located context =
  { row : Int
  , col : Int
  , context : context
  }



-- RUN


{-| This works just like [`Parser.run`](/package/gren-lang/parser/latest/Parser#run).
The only difference is that when it fails, it has much more precise information
for each dead end.
-}
run : Parser c x a -> String -> Result (Array (DeadEnd c x)) a
run (Parser parse) src =
  when parse { src = src, offset = 0, indent = 1, context = [], row = 1, col = 1} is
    Good { value } ->
      Ok value

    Bad { bag } ->
      Err (bagToArray bag [])



-- PROBLEMS


{-| Say you are parsing a function named `viewHealthData` that contains a list.
You might get a `DeadEnd` like this:

```gren
{ row = 18
, col = 22
, problem = UnexpectedComma
, contextStack =
    [ { row = 14
      , col = 1
      , context = Definition "viewHealthData"
      }
    , { row = 15
      , col = 4
      , context = List
      }
    ]
}
```

We have a ton of information here! So in the error message, we can say that “I
ran into an issue when parsing a list in the definition of `viewHealthData`. It
looks like there is an extra comma.” Or maybe something even better!

Furthermore, many parsers just put a mark where the problem manifested. By
tracking the `row` and `col` of the context, we can show a much larger region
as a way of indicating “I thought I was parsing this thing that starts over
here.” Otherwise you can get very confusing error messages on a missing `]` or
`}` or `)` because “I need more indentation” on something unrelated.

**Note:** Rows and columns are counted like a text editor. The beginning is `row=1`
and `col=1`. The `col` increments as characters are chomped. When a `\n` is chomped,
`row` is incremented and `col` starts over again at `1`.
-}
type alias DeadEnd context problem =
  { row : Int
  , col : Int
  , problem : problem
  , contextStack : Array { row : Int, col : Int, context : context }
  }


type Bag c x
  = Empty
  | AddRight { bag : (Bag c x), deadEnd : (DeadEnd c x) }
  | Append { left : (Bag c x), right : (Bag c x) }


fromState : State c -> x -> Bag c x
fromState s x =
  AddRight
    { bag = Empty
    , deadEnd =
      { row = s.row
      , col = s.col
      , problem = x
      , contextStack = s.context
      }
    }


fromInfo : Int -> Int -> x -> Array (Located c) -> Bag c x
fromInfo row col x context =
  AddRight
    { bag = Empty 
    , deadEnd =
      { row = row
      , col = col
      , problem = x
      , contextStack = context
      }
    }


bagToArray : Bag c x -> Array (DeadEnd c x) -> Array (DeadEnd c x)
bagToArray bag array =
  when bag is
    Empty ->
      array

    AddRight { bag = bag1, deadEnd = x } ->
      bagToArray bag1 (Array.pushFirst x array)

    Append { left = bag1, right = bag2 } ->
      bagToArray bag1 (bagToArray bag2 array)


-- PRIMITIVES


{-| Just like [`Parser.succeed`](Parser#succeed)
-}
succeed : a -> Parser c x a
succeed a =
  Parser <| \s ->
    Good { pred = False, value = a, state = s }


{-| Just like [`Parser.problem`](Parser#problem) except you provide a custom
type for your problem.
-}
problem : x -> Parser c x a
problem x =
  Parser <| \s ->
    Bad { pred = False, bag = (fromState s x) }



-- MAPPING


{-| Just like [`Parser.map`](Parser#map)
-}
map : (a -> b) -> Parser c x a -> Parser c x b
map func (Parser parse) =
  Parser <| \s0 ->
    when parse s0 is
      Good { pred = p, value = a, state = s1 } ->
        Good { pred = p, value = (func a), state = s1 }

      Bad { pred, bag } ->
        Bad { pred = pred, bag = bag }


{-| Transform the `Error` of a parser.
-}
mapError : (errA -> errB) -> Parser c errA x -> Parser c errB x
mapError func (Parser parse) =
  Parser <| \s0 ->
    when parse s0 is
      Good { pred = p, value = a, state = s1 } ->
        Good { pred = p, value = a, state = s1 }

      Bad { pred, bag } ->
        Bad { pred = pred, bag = mapBagProblem func bag }


mapBagProblem : (a -> b) -> Bag c a -> Bag c b
mapBagProblem mapper bag =
  when bag is
    Empty ->
      Empty

    AddRight { bag = bag1, deadEnd } ->
      AddRight
        { bag = mapBagProblem mapper bag1
        , deadEnd =
          { row = deadEnd.row
          , col = deadEnd.col
          , problem = mapper deadEnd.problem
          , contextStack = deadEnd.contextStack
          }
        }

    Append { left = bag1, right = bag2 } ->
      Append
        { left = mapBagProblem mapper bag1
        , right = mapBagProblem mapper bag2
        }


map2 : (a -> b -> value) -> Parser c x a -> Parser c x b -> Parser c x value
map2 func (Parser parseA) (Parser parseB) =
  Parser <| \s0 ->
    when parseA s0 is
      Bad { pred, bag = x } ->
        Bad { pred = pred, bag = x }

      Good { pred = p1, value = a, state = s1 } ->
        when parseB s1 is
          Bad { pred = p2, bag = x } ->
            Bad { pred = (p1 || p2), bag = x }

          Good { pred = p2, value = b, state = s2 } ->
            Good { pred = (p1 || p2), value = (func a b), state = s2 }


{-| Just like [keep](Parser#keep) from the `Parser` module.
-}
keep : Parser c x a -> Parser c x (a -> b) -> Parser c x b
keep parseArg parseFunc =
  map2 (<|) parseFunc parseArg


{-| Just like [skip](Parser#skip) from the `Parser` module.
-}
skip : Parser c x ignore -> Parser c x keep -> Parser c x keep
skip ignoreParser keepParser =
  map2 (\val _ -> val) keepParser ignoreParser


-- AND THEN


{-| Just like [`Parser.andThen`](Parser#andThen)
-}
andThen : (a -> Parser c x b) -> Parser c x a -> Parser c x b
andThen callback (Parser parseA) =
  Parser <| \s0 ->
    when parseA s0 is
      Bad { pred = p, bag = x } ->
        Bad { pred = p, bag = x }

      Good { pred = p1, value = a, state = s1 } ->
        let
          (Parser parseB) =
            callback a
        in
        when parseB s1 is
          Bad { pred = p2, bag = x } ->
            Bad { pred = (p1 || p2), bag = x }

          Good { pred = p2, value = b, state = s2 } ->
            Good { pred = (p1 || p2), value = b, state = s2 }



-- LAZY


{-| Just like [`Parser.lazy`](Parser#lazy)
-}
lazy : ({} -> Parser c x a) -> Parser c x a
lazy thunk =
  Parser <| \s ->
    let
      (Parser parse) =
        thunk {}
    in
    parse s



-- ONE OF


{-| Just like [`Parser.oneOf`](Parser#oneOf)
-}
oneOf : Array (Parser c x a) -> Parser c x a
oneOf parsers =
  Parser <| \s -> oneOfHelp s Empty parsers


oneOfHelp : State c -> Bag c x -> Array (Parser c x a) -> PStep c x a
oneOfHelp s0 bag parsers =
  when Array.popFirst parsers is
    Nothing ->
      Bad { pred = False, bag = bag }

    Just { first = Parser parse, rest = remainingParsers } ->
      when parse s0 is
        Good _ as step ->
          step

        Bad { pred = p, bag = x } as step ->
          if p then
            step
          else
            oneOfHelp s0 (Append { left = bag, right = x }) remainingParsers



-- LOOP


{-| Just like [`Parser.Step`](Parser#Step)
-}
type Step state a
  = Loop state
  | Done a


{-| Just like [`Parser.loop`](Parser#loop)
-}
loop : state -> (state -> Parser c x (Step state a)) -> Parser c x a
loop state callback =
  Parser <| \s ->
    loopHelp False state callback s


loopHelp : Bool -> state -> (state -> Parser c x (Step state a)) -> State c -> PStep c x a
loopHelp p state callback s0 =
  let
    (Parser parse) =
      callback state
  in
  when parse s0 is
    Good { pred = p1, value = step, state = s1 } ->
      when step is
        Loop newState ->
          loopHelp (p || p1) newState callback s1

        Done result ->
          Good { pred = (p || p1), value = result, state = s1 }

    Bad { pred = p1, bag = x } ->
      Bad { pred = (p || p1), bag = x }



-- BACKTRACKABLE


{-| Just like [`Parser.backtrackable`](Parser#backtrackable)
-}
backtrackable : Parser c x a -> Parser c x a
backtrackable (Parser parse) =
  Parser <| \s0 ->
    when parse s0 is
      Bad { bag = x } ->
        Bad { pred = False, bag = x }

      Good { value = a, state = s1 } ->
        Good { pred = False, value = a, state = s1 }


{-| Just like [`Parser.commit`](Parser#commit)
-}
commit : a -> Parser c x a
commit a =
  Parser <| \s -> Good { pred = True, value = a, state = s }


-- KEYWORD


{-| Just like [`Parser.keyword`](Parser#keyword) except you provide a `Token`
to clearly indicate your custom type of problems:

    let_ : Parser Context Problem {}
    let_ =
      symbol (Token "let" ExpectingLet)

Note that this would fail to chomp `letter` because of the subsequent
characters. Use `token` if you do not want that last letter check.
-}
keyword : String -> x -> Parser c x {}
keyword kwd expecting =
  let
    progress =
      not (String.isEmpty kwd)
  in
  Parser <| \s ->
    let
      { newOffset, newRow, newCol } =
        isSubString kwd s.offset s.row s.col s.src
    in
    if newOffset == -1 || 0 <= isSubChar (\c -> Char.isAlphaNum c || c == '_') newOffset s.src then
      Bad { pred = False, bag = (fromState s expecting) }
    else
      Good 
        { pred =progress
        , value = {}
        , state =
          { src = s.src
          , offset = newOffset
          , indent = s.indent
          , context = s.context
          , row = newRow
          , col = newCol
          }
        }



-- TOKEN


{-| Just like [`Parser.token`](Parser#token) except you provide a `Token`
specifying your custom type of problems.
-}
token : String -> x -> Parser c x {}
token str expecting =
  let
    progress =
      not (String.isEmpty str)
  in
  Parser <| \s ->
    let
      { newOffset, newRow, newCol } =
        isSubString str s.offset s.row s.col s.src
    in
    if newOffset == -1 then
      Bad { pred = False, bag = (fromState s expecting) }
    else
      Good
        { pred = progress
        , value = {}
        , state =
          { src = s.src
          , offset = newOffset
          , indent = s.indent
          , context = s.context
          , row = newRow
          , col = newCol
          }
        }


-- INT


{-| Just like [`Parser.int`](Parser#int) where you have to handle negation
yourself. The only difference is that you provide a two potential problems:

    int : x -> x -> Parser c x Int
    int expecting invalid =
      number
        { int = Ok identity
        , hex = Err invalid
        , octal = Err invalid
        , binary = Err invalid
        , float = Err invalid
        , invalid = invalid
        , expecting = expecting
        }

You can use problems like `ExpectingInt` and `InvalidNumber`.
-}
int : x -> Parser c x Int
int invalid =
  oneOf
    [ chompIf (\c -> c == '0') invalid
      |> andThen
        (\_ ->
          oneOf
            [ chompIf Char.isDigit invalid
                |> andThen (\_ -> problem invalid)
            , succeed 0
            ]
        )
    , chompIf Char.isDigit invalid
      |> skip (chompWhile Char.isDigit)
      |> getChompedString
      |> andThen
        (\str ->
          when String.toInt str is
            Nothing ->
              problem invalid

            Just num ->
              succeed num
        )
    ]


-- END


{-| Just like [`Parser.end`](Parser#end) except you provide the problem that
arises when the parser is not at the end of the input.
-}
end : x -> Parser c x {}
end x =
  Parser <| \s ->
    if String.unitLength s.src == s.offset then
      Good { pred = False, value = {}, state = s }
    else
      Bad { pred = False, bag = (fromState s x) }



-- CHOMPED STRINGS


{-| Just like [`Parser.getChompedString`](Parser#getChompedString)
-}
getChompedString : Parser c x a -> Parser c x String
getChompedString parser =
  mapChompedString (\str _ -> str) parser


{-| Just like [`Parser.mapChompedString`](Parser#mapChompedString)
-}
mapChompedString : (String -> a -> b) -> Parser c x a -> Parser c x b
mapChompedString func (Parser parse) =
  Parser <| \s0 ->
    when parse s0 is
      Bad { pred = p, bag = x } ->
        Bad { pred = p, bag = x }

      Good { pred = p, value = a, state = s1 } ->
        Good { pred = p, value = (func (String.sliceUnits s0.offset s1.offset s0.src) a), state = s1 }



-- CHOMP IF


{-| Just like [`Parser.chompIf`](Parser#chompIf) except you provide a problem
in case a character cannot be chomped.
-}
chompIf : (Char -> Bool) -> x -> Parser c x {}
chompIf isGood expecting =
  Parser <| \s ->
    let
      newOffset = isSubChar isGood s.offset s.src
    in
    -- not found
    if newOffset == -1 then
      Bad { pred = False, bag = (fromState s expecting) }

    -- newline
    else if newOffset == -2 then
      Good
        { pred =True
        , value = {}
        , state =
          { src = s.src
          , offset = s.offset + 1
          , indent = s.indent
          , context = s.context
          , row = s.row + 1
          , col = 1
          }
        }

    -- found
    else
      Good
        { pred = True
        , value = {}
        , state =
          { src = s.src
          , offset = newOffset
          , indent = s.indent
          , context = s.context
          , row = s.row
          , col = s.col + 1
          }
        }



-- CHOMP WHILE


{-| Just like [`Parser.chompWhile`](Parser#chompWhile)
-}
chompWhile : (Char -> Bool) -> Parser c x {}
chompWhile isGood =
  Parser <| \s ->
    chompWhileHelp isGood s.offset s.row s.col s


chompWhileHelp : (Char -> Bool) -> Int -> Int -> Int -> State c -> PStep c x {}
chompWhileHelp isGood offset row col s0 =
  let
    newOffset = isSubChar isGood offset s0.src
  in
  -- no match
  if newOffset == -1 then
    Good
      { pred = (s0.offset < offset)
      , value = {}
      , state =
        { src = s0.src
        , offset = offset
        , indent = s0.indent
        , context = s0.context
        , row = row
        , col = col
        }
      }

  -- matched a newline
  else if newOffset == -2 then
    chompWhileHelp isGood (offset + 1) (row + 1) 1 s0

  -- normal match
  else
    chompWhileHelp isGood newOffset row (col + 1) s0



-- CHOMP UNTIL


{-| Just like [`Parser.chompUntil`](Parser#chompUntil) except you provide a
`Token` in case you chomp all the way to the end of the input without finding
what you need.
-}
chompUntil : String -> x -> Parser c x {}
chompUntil str expecting =
  Parser <| \s ->
    let
      { newOffset, newRow, newCol } =
        findSubString str s.offset s.row s.col s.src
    in
    if newOffset == -1 then
      Bad { pred = False, bag = (fromInfo newRow newCol expecting s.context) }

    else
      Good 
        { pred = (s.offset < newOffset)
        , value = {}
        , state =
          { src = s.src
          , offset = newOffset
          , indent = s.indent
          , context = s.context
          , row = newRow
          , col = newCol
          }
        }


{-| Just like [`Parser.chompUntilEndOr`](Parser#chompUntilEndOr)
-}
chompUntilEndOr : String -> Parser c x {}
chompUntilEndOr str =
  Parser <| \s ->
    let
      { newOffset, newRow, newCol } =
        findSubString str s.offset s.row s.col s.src

      adjustedOffset =
        if newOffset < 0 then String.unitLength s.src else newOffset
    in
    Good
      { pred = (s.offset < adjustedOffset)
      , value = {}
      , state =
        { src = s.src
        , offset = adjustedOffset
        , indent = s.indent
        , context = s.context
        , row = newRow
        , col = newCol
        }
      }



-- CONTEXT


{-| This is how you mark that you are in a certain context. For example, here
is a rough outline of some code that uses `inContext` to mark when you are
parsing a specific definition:

    import Char
    import Parser.Advanced exposing (..)
    import Set

    type Context
      = Definition String
      | List

    definition : Parser Context Problem Expr
    definition =
      functionName
        |> andThen definitionBody

    definitionBody : String -> Parser Context Problem Expr
    definitionBody name =
      inContext (Definition name) <|
        succeed (Function name)
          |= arguments
          |. symbol (Token "=" ExpectingEquals)
          |= expression

    functionName : Parser c Problem String
    functionName =
      variable
        { start = Char.isLower
        , inner = Char.isAlphaNum
        , reserved = Set.fromList ["let","in"]
        , expecting = ExpectingFunctionName
        }

First we parse the function name, and then we parse the rest of the definition.
Importantly, we call `inContext` so that any dead end that occurs in
`definitionBody` will get this extra context information. That way you can say
things like, “I was expecting an equals sign in the `view` definition.” Context!
-}
inContext : context -> Parser context x a -> Parser context x a
inContext context (Parser parse) =
  Parser <| \s0 ->
    when parse (changeContext (Array.pushFirst { row = s0.row, col = s0.col, context = context } s0.context) s0) is
      Good { pred = p, value = a, state = s1 } ->
        Good { pred = p, value = a, state = (changeContext s0.context s1) }

      Bad _ as step ->
        step


changeContext : Array (Located c) -> State c -> State c
changeContext newContext s =
  { src = s.src
  , offset = s.offset
  , indent = s.indent
  , context = newContext
  , row = s.row
  , col = s.col
  }



-- INDENTATION


{-| Just like [`Parser.getIndent`](Parser#getIndent)
-}
getIndent : Parser c x Int
getIndent =
  Parser <| \s -> Good { pred = False, value = s.indent, state = s }


{-| Just like [`Parser.withIndent`](Parser#withIndent)
-}
withIndent : Int -> Parser c x a -> Parser c x a
withIndent newIndent (Parser parse) =
  Parser <| \s0 ->
    when parse (changeIndent newIndent s0) is
      Good { pred = p, value = a, state = s1 } ->
        Good { pred = p, value = a, state = (changeIndent s0.indent s1) }

      Bad { pred = p, bag = x } ->
        Bad { pred = p, bag = x }


changeIndent : Int -> State c -> State c
changeIndent newIndent s =
  { src = s.src
  , offset = s.offset
  , indent = newIndent
  , context = s.context
  , row = s.row
  , col = s.col
  }



-- POSITION


{-| Just like [`Parser.getPosition`](Parser#getPosition)
-}
getPosition : Parser c x { row: Int, col: Int }
getPosition =
  Parser <| \s -> Good { pred = False, value = { row = s.row, col = s.col }, state = s }


{-| Just like [`Parser.getRow`](Parser#getRow)
-}
getRow : Parser c x Int
getRow =
  Parser <| \s -> Good { pred = False, value = s.row, state = s }


{-| Just like [`Parser.getCol`](Parser#getCol)
-}
getCol : Parser c x Int
getCol =
  Parser <| \s -> Good { pred = False, value = s.col, state = s }


{-| Just like [`Parser.getOffset`](Parser#getOffset)
-}
getOffset : Parser c x Int
getOffset =
  Parser <| \s -> Good { pred = False, value = s.offset, state = s }


{-| Just like [`Parser.getSource`](Parser#getSource)
-}
getSource : Parser c x String
getSource =
  Parser <| \s -> Good { pred = False, value = s.src, state = s }



-- LOW-LEVEL HELPERS


{-| When making a fast parser, you want to avoid allocation as much as
possible. That means you never want to mess with the source string, only
keep track of an offset into that string.

You use `isSubString` like this:

    isSubString "let" offset row col "let x = 4 in x"
        --==> ( newOffset, newRow, newCol )

You are looking for `"let"` at a given `offset`. On failure, the
`newOffset` is `-1`. On success, the `newOffset` is the new offset. With
our `"let"` example, it would be `offset + 3`.

You also provide the current `row` and `col` which do not align with
`offset` in a clean way. For example, when you see a `\n` you are at
`row = row + 1` and `col = 1`. Furthermore, some UTF16 characters are
two words wide, so even if there are no newlines, `offset` and `col`
may not be equal.
-}
isSubString : String -> Int -> Int -> Int -> String -> { newOffset: Int, newRow: Int, newCol: Int }
isSubString =
  Gren.Kernel.Parser.isSubString


{-| Again, when parsing, you want to allocate as little as possible.
So this function lets you say:

    isSubChar isSpace offset "this is the source string"
        --==> newOffset

The `(Char -> Bool)` argument is called a predicate.
The `newOffset` value can be a few different things:

  - `-1` means that the predicate failed
  - `-2` means the predicate succeeded with a `\n`
  - otherwise you will get `offset + 1` or `offset + 2`
    depending on whether the UTF16 character is one or two
    words wide.
-}
isSubChar : (Char -> Bool) -> Int -> String -> Int
isSubChar =
  Gren.Kernel.Parser.isSubChar


{-| Check an offset in the string. Is it equal to the given Char? Are they
both ASCII characters?
-}
isAsciiCode : Int -> Int -> String -> Bool
isAsciiCode =
  Gren.Kernel.Parser.isAsciiCode


{-| Find a substring after a given offset.

    findSubString "42" offset row col "Is 42 the answer?"
        --==> (newOffset, newRow, newCol)

If `offset = 0` we would get `(3, 1, 4)`
If `offset = 7` we would get `(-1, 1, 18)`
-}
findSubString : String -> Int -> Int -> Int -> String -> { newOffset: Int, newRow: Int, newCol: Int }
findSubString =
  Gren.Kernel.Parser.findSubString



-- VARIABLES


{-| Just like [`Parser.variable`](Parser#variable) except you specify the
problem yourself.
-}
variable :
  { start : Char -> Bool
  , inner : Char -> Bool
  , reserved : Set.Set String
  , expecting : x
  }
  -> Parser c x String
variable i =
  Parser <| \s ->
    let
      firstOffset =
        isSubChar i.start s.offset s.src
    in
    if firstOffset == -1 then
      Bad { pred = False, bag = (fromState s i.expecting) }
    else
      let
        s1 =
          if firstOffset == -2 then
            varHelp i.inner (s.offset + 1) (s.row + 1) 1 s.src s.indent s.context
          else
            varHelp i.inner firstOffset s.row (s.col + 1) s.src s.indent s.context

        name =
          String.sliceUnits s.offset s1.offset s.src
      in
      if Set.member name i.reserved then
        Bad { pred = False, bag = (fromState s i.expecting) }
      else
        Good { pred = True, value = name, state = s1 }


varHelp : (Char -> Bool) -> Int -> Int -> Int -> String -> Int -> Array (Located c) -> State c
varHelp isGood offset row col src indent context =
  let
    newOffset = isSubChar isGood offset src
  in
  if newOffset == -1 then
    { src = src
    , offset = offset
    , indent = indent
    , context = context
    , row = row
    , col = col
    }

  else if newOffset == -2 then
    varHelp isGood (offset + 1) (row + 1) 1 src indent context

  else
    varHelp isGood newOffset row (col + 1) src indent context



-- SEQUENCES


type alias Token x =
  { string : String
  , expecting : x
  }


{-| Just like [`Parser.sequence`](Parser#sequence) except with a `Token` for
the start, separator, and end. That way you can specify your custom type of
problem for when something is not found.
-}
sequence
  : { start : Token x
    , separator : Token x
    , end : Token x
    , spaces : Parser c x {}
    , item : Parser c x a
    , trailing : Trailing
    }
  -> Parser c x (Array a)
sequence i =
  revSkip (token i.start.string i.start.expecting) <|
    revSkip i.spaces <|
      sequenceEnd
        (token i.end.string i.end.expecting)
        i.spaces
        i.item
        (token i.separator.string i.separator.expecting)
        i.trailing


{-| What’s the deal with trailing commas? Are they `Forbidden`?
Are they `Optional`? Are they `Mandatory`? Welcome to [shapes
club](https://poorlydrawnlines.com/comic/shapes-club/)!
-}
type Trailing = Forbidden | Optional | Mandatory


revSkip : Parser c x ignore -> Parser c x keep -> Parser c x keep
revSkip iParser kParser =
  map2 revAlways iParser kParser


revAlways : a -> b -> b
revAlways _ b =
  b


sequenceEnd : Parser c x {} -> Parser c x {} -> Parser c x a -> Parser c x {} -> Trailing -> Parser c x (Array a)
sequenceEnd ender ws parseItem sep trailing =
  let
    chompRest item =
      when trailing is
        Forbidden ->
          loop [item] (sequenceEndForbidden ender ws parseItem sep)

        Optional ->
          loop [item] (sequenceEndOptional ender ws parseItem sep)

        Mandatory ->
          skip ender
            ( revSkip ws <| revSkip sep <| revSkip ws <|
                loop [item] (sequenceEndMandatory ws parseItem sep)
            )
  in
  oneOf
    [ parseItem |> andThen chompRest
    , ender |> map (\_ -> [])
    ]


sequenceEndForbidden : Parser c x {} -> Parser c x {} -> Parser c x a -> Parser c x {} -> Array a -> Parser c x (Step (Array a) (Array a))
sequenceEndForbidden ender ws parseItem sep items =
  revSkip ws <|
    oneOf
      [ revSkip sep <| revSkip ws <| map (\item -> Loop (Array.pushLast item items)) parseItem
      , ender |> map (\_ -> Done items )
      ]


sequenceEndOptional : Parser c x {} -> Parser c x {} -> Parser c x a -> Parser c x {} -> Array a -> Parser c x (Step (Array a) (Array a))
sequenceEndOptional ender ws parseItem sep items =
  let
    parseEnd =
      map (\_ -> Done items) ender
  in
  revSkip ws <|
    oneOf
      [ revSkip sep <| revSkip ws <|
          oneOf
            [ parseItem |> map (\item -> Loop (Array.pushLast item items))
            , parseEnd
            ]
      , parseEnd
      ]


sequenceEndMandatory : Parser c x {} -> Parser c x a -> Parser c x {} -> Array a -> Parser c x (Step (Array a) (Array a))
sequenceEndMandatory ws parseItem sep items =
  oneOf
    [ map (\item -> Loop (Array.pushLast item items)) <|
        skip (skip (skip ws sep) ws) parseItem
    , map (\_ -> Done items) (succeed {})
    ]



-- WHITESPACE


{-| Just like [`Parser.spaces`](Parser#spaces)
-}
spaces : Parser c x {}
spaces =
  chompWhile (\c -> c == ' ' || c == '\n' || c == '\r')


{-| Just like [`Parser.lineComment`](Parser#lineComment) except you provide a
`Token` describing the starting symbol.
-}
lineComment : String -> x -> Parser c x {}
lineComment string expecting =
  skip (chompUntilEndOr "\n") (token string expecting)


{-| Just like [`Parser.multiComment`](Parser#multiComment) except with a
`Token` for the open and close symbols.
-}
multiComment : Token x -> Token x -> Nestable -> Parser c x {}
multiComment open close nestable =
  when nestable is
    NotNestable ->
      skip (chompUntil close.string close.expecting) (token open.string open.expecting)

    Nestable ->
      nestableComment open close


{-| Works just like [`Parser.Nestable`](Parser#Nestable) to help distinguish
between unnestable `/*` `*/` comments like in JS and nestable `{-` `-}`
comments like in Gren.
-}
type Nestable = NotNestable | Nestable


nestableComment : Token x -> Token x -> Parser c x {}
nestableComment ({ string = oStr, expecting = oX } as open) ({ string = cStr, expecting = cX } as close) =
  when String.popFirst oStr is
    Nothing ->
      problem oX

    Just { first = openChar } ->
      when String.popFirst cStr is
        Nothing ->
          problem cX

        Just { first = closeChar } ->
          let
            isNotRelevant char =
              char /= openChar && char /= closeChar

            chompOpen =
              token oStr oX
          in
          skip (nestableHelp isNotRelevant chompOpen (token cStr cX) cX 1) chompOpen


nestableHelp : (Char -> Bool) -> Parser c x {} -> Parser c x {} -> x -> Int -> Parser c x {}
nestableHelp isNotRelevant open close expectingClose nestLevel =
  revSkip (chompWhile isNotRelevant) <|
    oneOf
      [ if nestLevel == 1 then
          close
        else
          close
            |> andThen (\_ -> nestableHelp isNotRelevant open close expectingClose (nestLevel - 1))
      , open
          |> andThen (\_ -> nestableHelp isNotRelevant open close expectingClose (nestLevel + 1))
      , chompIf isChar expectingClose
          |> andThen (\_ -> nestableHelp isNotRelevant open close expectingClose nestLevel)
      ]


isChar : Char -> Bool
isChar char =
  True
