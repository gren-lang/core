module String.Parser.Advanced exposing
  ( Parser, run, DeadEnd, Token
  , setPayload, getPayload, updatePayload, scopedUpdatePayload
  , int, token, keyword, variable, end
  , succeed, keep, skip, lazy, andThen, problem
  , oneOf, map, mapError, backtrackable, commit 
  , sequence, Trailing(..), loop, Step(..)
  , spaces, lineComment, multiComment, Nestable(..)
  , getChompedString, chompIf, chompChar, chompWhile, chompUntil, chompUntilEndOr, mapChompedString
  , getPosition, getRow, getCol, getOffset, getSource
  , Output, Extract, Expected(..), renderDeadEnds
  )


{-|

# Parsers
@docs Parser, run, DeadEnd, Token

# Payload
@docs setPayload, getPayload, updatePayload, scopedUpdatePayload

* * *
**Everything past here works just like in the
[`Parser`](/package/gren-lang/parser/latest/Parser) module, except that
you need to provide a `Problem` for certain scenarios.**
* * *

# Building Blocks
@docs int, token, keyword, variable, end

# Pipelines
@docs succeed, keep, skip, lazy, andThen, problem

# Branches
@docs oneOf, map, mapError, backtrackable, commit 

# Loops
@docs sequence, Trailing, loop, Step

# Whitespace
@docs spaces, lineComment, multiComment, Nestable

# Chompers
@docs getChompedString, chompIf, chompChar, chompWhile, chompUntil, chompUntilEndOr, mapChompedString

# Positions
@docs getPosition, getRow, getCol, getOffset, getSource

# Error formatting
@docs Output, Extract, Expected, renderDeadEnds
-}


import Basics exposing (..)
import Bitwise
import String exposing (String)
import Array exposing (Array)
import Char exposing (Char)
import Result exposing (Result(..))
import Maybe exposing (Maybe(..))
import Set


-- PARSERS


{-| An advanced `Parser` gives two ways to improve your error messages:

- `problem` &mdash; Instead of all errors being a `String`, you can create a
custom type like `type Problem = BadIndent | BadKeyword String` and track
problems much more precisely.
- `payload` &mdash; Sometimes you want to track information while you're parsing.
This could be things like comments for when you want to format code, indentation
levels, or what you're currently trying to parse. The payload gives you a place
to store arbitrary data, should you need it.

I recommend starting with the simpler [`Parser`][parser] module though, and
when you feel comfortable and want better error messages, you can create a type
alias like this:

```gren
import Parser.Advanced

type alias MyParser a =
  Parser.Advanced.Parser Payload Problem a

type Payload = Definition String | List | Record

type Problem = BadIndent | BadKeyword String
```

All of the functions from `Parser` should exist in `Parser.Advanced` in some
form, allowing you to switch over pretty easily.

[parser]: /package/gren-lang/parser/latest/Parser
-}
type Parser payload problem value =
  Parser (State payload -> PStep payload problem value)


type PStep payload problem value
  = Good { pred : Bool, value : value, state : State payload }
  | Bad { pred : Bool, bag : Bag payload problem }


type alias State payload =
  { src : String
  , offset : Int
  , row : Int
  , col : Int
  , payload : payload
  }


-- RUN


{-| This works just like [`Parser.run`](/package/gren-lang/parser/latest/Parser#run).
The only difference is that when it fails, it has much more precise information
for each dead end.
-}
run : Parser p x a -> p -> String -> Result (Array (DeadEnd p x)) a
run (Parser parse) initialPayload src =
  when parse { src = src, offset = 0, payload = initialPayload, row = 1, col = 1} is
    Good { value } ->
      Ok value

    Bad { bag } ->
      Err (bagToArray bag [])



-- PROBLEMS


{-| Say you are parsing a function named `viewHealthData` that contains a list.
You might get a `DeadEnd` like this:

```gren
{ row = 18
, col = 22
, problem = UnexpectedComma
, payload = List
}
```

We're using the `payload` to keep track of what we were parsing when the error
occurred. So in the error message, we can say that "I ran into an issue when
parsing a list. It looks like there is an extra comma." Or maybe something even
better!

By tracking the `row` and `col` where the problem occurred along with the payload,
we can provide helpful context about what the parser was doing. This is much
better than just marking where the problem manifested without any additional
information about the parsing state.

**Note:** Rows and columns are counted like a text editor. The beginning is `row=1`
and `col=1`. The `col` increments as characters are chomped. When a `\n` is chomped,
`row` is incremented and `col` starts over again at `1`.
-}
type alias DeadEnd payload problem =
  { row : Int
  , col : Int
  , problem : problem
  , payload : payload
  }


type Bag c x
  = Empty
  | AddRight { bag : Bag c x, deadEnd : DeadEnd c x }
  | Append { left : Bag c x, right : Bag c x }


fromState : State c -> x -> Bag c x
fromState s x =
  AddRight
    { bag = Empty
    , deadEnd =
      { row = s.row
      , col = s.col
      , problem = x
      , payload = s.payload
      }
    }


bagToArray : Bag c x -> Array (DeadEnd c x) -> Array (DeadEnd c x)
bagToArray bag array =
  when bag is
    Empty ->
      array

    AddRight { bag = bag1, deadEnd = x } ->
      bagToArray bag1 (Array.pushFirst x array)

    Append { left = bag1, right = bag2 } ->
      bagToArray bag1 (bagToArray bag2 array)


-- PRIMITIVES


{-| Just like [`Parser.succeed`](Parser#succeed)
-}
succeed : a -> Parser c x a
succeed a =
  Parser <| \s ->
    Good { pred = False, value = a, state = s }


{-| Just like [`Parser.problem`](Parser#problem) except you provide a custom
type for your problem.
-}
problem : x -> Parser c x a
problem x =
  Parser <| \s ->
    Bad { pred = False, bag = (fromState s x) }



-- MAPPING


{-| Just like [`Parser.map`](Parser#map)
-}
map : (a -> b) -> Parser c x a -> Parser c x b
map func (Parser parse) =
  Parser <| \s0 ->
    when parse s0 is
      Good { pred = p, value = a, state = s1 } ->
        Good { pred = p, value = (func a), state = s1 }

      Bad { pred, bag } ->
        Bad { pred = pred, bag = bag }


{-| Transform the `Error` of a parser.
-}
mapError : (errA -> errB) -> Parser c errA x -> Parser c errB x
mapError func (Parser parse) =
  Parser <| \s0 ->
    when parse s0 is
      Good { pred = p, value = a, state = s1 } ->
        Good { pred = p, value = a, state = s1 }

      Bad { pred, bag } ->
        Bad { pred = pred, bag = mapBagProblem func bag }


mapBagProblem : (a -> b) -> Bag c a -> Bag c b
mapBagProblem mapper bag =
  when bag is
    Empty ->
      Empty

    AddRight { bag = bag1, deadEnd } ->
      AddRight
        { bag = mapBagProblem mapper bag1
        , deadEnd =
          { row = deadEnd.row
          , col = deadEnd.col
          , problem = mapper deadEnd.problem
          , payload = deadEnd.payload
          }
        }

    Append { left = bag1, right = bag2 } ->
      Append
        { left = mapBagProblem mapper bag1
        , right = mapBagProblem mapper bag2
        }


map2 : (a -> b -> value) -> Parser c x a -> Parser c x b -> Parser c x value
map2 func (Parser parseA) (Parser parseB) =
  Parser <| \s0 ->
    when parseA s0 is
      Bad { pred, bag = x } ->
        Bad { pred = pred, bag = x }

      Good { pred = p1, value = a, state = s1 } ->
        when parseB s1 is
          Bad { pred = p2, bag = x } ->
            Bad { pred = (p1 || p2), bag = x }

          Good { pred = p2, value = b, state = s2 } ->
            Good { pred = (p1 || p2), value = (func a b), state = s2 }


{-| Just like [keep](Parser#keep) from the `Parser` module.
-}
keep : Parser c x a -> Parser c x (a -> b) -> Parser c x b
keep parseArg parseFunc =
  map2 (<|) parseFunc parseArg


{-| Just like [skip](Parser#skip) from the `Parser` module.
-}
skip : Parser c x ignore -> Parser c x keep -> Parser c x keep
skip ignoreParser keepParser =
  map2 (\val _ -> val) keepParser ignoreParser


-- AND THEN


{-| Just like [`Parser.andThen`](Parser#andThen)
-}
andThen : (a -> Parser c x b) -> Parser c x a -> Parser c x b
andThen callback (Parser parseA) =
  Parser <| \s0 ->
    when parseA s0 is
      Bad { pred = p, bag = x } ->
        Bad { pred = p, bag = x }

      Good { pred = p1, value = a, state = s1 } ->
        let
          (Parser parseB) =
            callback a
        in
        when parseB s1 is
          Bad { pred = p2, bag = x } ->
            Bad { pred = (p1 || p2), bag = x }

          Good { pred = p2, value = b, state = s2 } ->
            Good { pred = (p1 || p2), value = b, state = s2 }



-- LAZY


{-| Just like [`Parser.lazy`](Parser#lazy)
-}
lazy : ({} -> Parser c x a) -> Parser c x a
lazy thunk =
  Parser <| \s ->
    let
      (Parser parse) =
        thunk {}
    in
    parse s



-- ONE OF


{-| Just like [`Parser.oneOf`](Parser#oneOf)
-}
oneOf : Array (Parser c x a) -> Parser c x a
oneOf parsers =
  Parser <| \s -> oneOfHelp s Empty parsers


oneOfHelp : State c -> Bag c x -> Array (Parser c x a) -> PStep c x a
oneOfHelp s0 bag parsers =
  when Array.popFirst parsers is
    Nothing ->
      Bad { pred = False, bag = bag }

    Just { first = Parser parse, rest = remainingParsers } ->
      when parse s0 is
        Good _ as step ->
          step

        Bad { pred = p, bag = x } as step ->
          if p then
            step
          else
            oneOfHelp s0 (Append { left = bag, right = x }) remainingParsers



-- LOOP


{-| Just like [`Parser.Step`](Parser#Step)
-}
type Step state a
  = Loop state
  | Done a


{-| Just like [`Parser.loop`](Parser#loop)
-}
loop : state -> (state -> Parser c x (Step state a)) -> Parser c x a
loop state callback =
  Parser <| \s ->
    loopHelp False state callback s


loopHelp : Bool -> state -> (state -> Parser c x (Step state a)) -> State c -> PStep c x a
loopHelp p state callback s0 =
  let
    (Parser parse) =
      callback state
  in
  when parse s0 is
    Good { pred = p1, value = step, state = s1 } ->
      when step is
        Loop newState ->
          loopHelp (p || p1) newState callback s1

        Done result ->
          Good { pred = (p || p1), value = result, state = s1 }

    Bad { pred = p1, bag = x } ->
      Bad { pred = (p || p1), bag = x }



-- BACKTRACKABLE


{-| Just like [`Parser.backtrackable`](Parser#backtrackable)
-}
backtrackable : Parser c x a -> Parser c x a
backtrackable (Parser parse) =
  Parser <| \s0 ->
    when parse s0 is
      Bad { bag = x } ->
        Bad { pred = False, bag = x }

      Good { value = a, state = s1 } ->
        Good { pred = False, value = a, state = s1 }


{-| Just like [`Parser.commit`](Parser#commit)
-}
commit : a -> Parser c x a
commit a =
  Parser <| \s -> Good { pred = True, value = a, state = s }


-- KEYWORD


{-| Just like [`Parser.keyword`](Parser#keyword) except you provide a
problem in case the parser fails:

    let_ : Parser Payload Problem {}
    let_ =
      token "let" ExpectingLet

Note that this would fail to chomp `letter` because of the subsequent
characters. Use `token` if you do not want that last letter check.
-}
keyword : String -> x -> Parser c x {}
keyword kwd expecting =
  let
    progress =
      not (String.isEmpty kwd)
  in
  Parser <| \s ->
    let
      { newOffset, newRow, newCol } =
        isSubString kwd s.offset s.row s.col s.src
    in
    if newOffset == -1 || 0 <= isSubChar (\c -> Char.isAlphaNum c || c == '_') newOffset s.src then
      Bad { pred = False, bag = (fromState s expecting) }
    else
      Good 
        { pred =progress
        , value = {}
        , state =
          { src = s.src
          , offset = newOffset
          , row = newRow
          , col = newCol
          , payload = s.payload
          }
        }



-- TOKEN


{-| Just like [`Parser.token`](Parser#token) except you provide a
problem in case the parser fails.
-}
token : String -> x -> Parser c x {}
token str expecting =
  let
    progress =
      not (String.isEmpty str)
  in
  Parser <| \s ->
    let
      { newOffset, newRow, newCol } =
        isSubString str s.offset s.row s.col s.src
    in
    if newOffset == -1 then
      Bad { pred = False, bag = (fromState s expecting) }
    else
      Good
        { pred = progress
        , value = {}
        , state =
          { src = s.src
          , offset = newOffset
          , row = newRow
          , col = newCol
          , payload = s.payload
          }
        }


-- INT


{-| Just like [`Parser.int`](Parser#int) where you have to handle negation
yourself. The only difference is that you provide a problem in case
the parser fails.
-}
int : x -> Parser c x Int
int invalid =
  oneOf
    [ succeed 0
      |> skip (chompChar '0' invalid)
    , chompIf Char.isDigit invalid
      |> skip (chompWhile Char.isDigit)
      |> getChompedString
      |> andThen
        (\str ->
          when String.toInt str is
            Nothing ->
              problem invalid

            Just num ->
              succeed num
        )
    ]


-- END


{-| Just like [`Parser.end`](Parser#end) except you provide the problem that
arises when the parser is not at the end of the input.
-}
end : x -> Parser c x {}
end x =
  Parser <| \s ->
    if String.unitLength s.src == s.offset then
      Good { pred = False, value = {}, state = s }
    else
      Bad { pred = False, bag = (fromState s x) }



-- CHOMPED STRINGS


{-| Just like [`Parser.getChompedString`](Parser#getChompedString)
-}
getChompedString : Parser c x a -> Parser c x String
getChompedString parser =
  mapChompedString (\str _ -> str) parser


{-| Just like [`Parser.mapChompedString`](Parser#mapChompedString)
-}
mapChompedString : (String -> a -> b) -> Parser c x a -> Parser c x b
mapChompedString func (Parser parse) =
  Parser <| \s0 ->
    when parse s0 is
      Bad { pred = p, bag = x } ->
        Bad { pred = p, bag = x }

      Good { pred = p, value = a, state = s1 } ->
        Good { pred = p, value = (func (String.sliceUnits s0.offset s1.offset s0.src) a), state = s1 }



-- CHOMP IF


{-| Just like [`Parser.chompIf`](Parser#chompIf) except you provide a problem
in case a character cannot be chomped.
-}
chompIf : (Char -> Bool) -> x -> Parser c x {}
chompIf isGood expecting =
  Parser <| \s ->
    let
      newOffset = isSubChar isGood s.offset s.src
    in
    -- not found
    if newOffset == -1 then
      Bad { pred = False, bag = fromState s expecting }

    -- newline
    else if newOffset == -2 then
      Good
        { pred =True
        , value = {}
        , state =
          { src = s.src
          , offset = s.offset + 1
          , row = s.row + 1
          , col = 1
          , payload = s.payload
          }
        }

    -- found
    else
      Good
        { pred = True
        , value = {}
        , state =
          { src = s.src
          , offset = newOffset
          , row = s.row
          , col = s.col + 1
          , payload = s.payload
          }
        }


{-| Just like [`Parser.chompChar`](Parser#chompChar) except you provide a problem
in case a character cannot be chomped.
-}
chompChar : Char -> x -> Parser c x {}
chompChar chr expecting =
  chompIf (\c -> c == chr) expecting


-- CHOMP WHILE


{-| Just like [`Parser.chompWhile`](Parser#chompWhile)
-}
chompWhile : (Char -> Bool) -> Parser c x {}
chompWhile isGood =
  Parser <| \s ->
    chompWhileHelp isGood s.offset s.row s.col s


chompWhileHelp : (Char -> Bool) -> Int -> Int -> Int -> State c -> PStep c x {}
chompWhileHelp isGood offset row col s0 =
  let
    newOffset = isSubChar isGood offset s0.src
  in
  -- no match
  if newOffset == -1 then
    Good
      { pred = (s0.offset < offset)
      , value = {}
      , state =
        { src = s0.src
        , offset = offset
        , row = row
        , col = col
        , payload = s0.payload
        }
      }

  -- matched a newline
  else if newOffset == -2 then
    chompWhileHelp isGood (offset + 1) (row + 1) 1 s0

  -- normal match
  else
    chompWhileHelp isGood newOffset row (col + 1) s0



-- CHOMP UNTIL


{-| Just like [`Parser.chompUntil`](Parser#chompUntil) except you provide the
problem in case you chomp all the way to the end of the input without finding
what you need.
-}
chompUntil : String -> x -> Parser c x {}
chompUntil str expecting =
  Parser <| \s ->
    let
      { newOffset, newRow, newCol } =
        findSubString str s.offset s.row s.col s.src
    in
    if newOffset == -1 then
      Bad { pred = False, bag = fromState s expecting }

    else
      Good 
        { pred = s.offset < newOffset
        , value = {}
        , state =
          { src = s.src
          , offset = newOffset
          , row = newRow
          , col = newCol
          , payload = s.payload
          }
        }


{-| Just like [`Parser.chompUntilEndOr`](Parser#chompUntilEndOr)
-}
chompUntilEndOr : String -> Parser c x {}
chompUntilEndOr str =
  Parser <| \s ->
    let
      { newOffset, newRow, newCol } =
        findSubString str s.offset s.row s.col s.src

      adjustedOffset =
        if newOffset < 0 then String.unitLength s.src else newOffset
    in
    Good
      { pred = (s.offset < adjustedOffset)
      , value = {}
      , state =
        { src = s.src
        , offset = adjustedOffset
        , row = newRow
        , col = newCol
        , payload = s.payload
        }
      }



-- PAYLOAD


{-| This is how you mark that you are in a certain payload. For example, here
is a rough outline of some code that uses `inContext` to mark when you are
parsing a specific definition:

    import Char
    import Parser.Advanced exposing (..)

    type Payload
      = Definition String
      | List

    definition : Parser Payload Problem Expr
    definition =
      functionName
        |> andThen definitionBody

    definitionBody : String -> Parser Payload Problem Expr
    definitionBody name =
      inContext (Definition name) <|
        succeed (Function name)
          |> keep arguments
          |> skip (token "=" ExpectingEquals)
          |> keep expression

    functionName : Parser c Problem String
    functionName =
      variable
        { start = Char.isLower
        , inner = Char.isAlphaNum
        , expecting = ExpectingFunctionName
        }

First we parse the function name, and then we parse the rest of the definition.
Importantly, we call `inContext` so that any dead end that occurs in
`definitionBody` will get this extra payload information. That way you can say
things like, "I was expecting an equals sign in the `view` definition." Payload!
-}
setPayload : payload -> Parser payload x a -> Parser payload x a
setPayload payload parser =
  updatePayload (\_ -> payload) parser


getPayload : Parser payload x payload
getPayload =
  Parser <| \s -> Good { pred = False, value = s.payload, state = s }


updatePayload : (payload -> payload) -> Parser payload x a -> Parser payload x a
updatePayload updater (Parser parse) =
  Parser <| \s -> parse (setStatePayload (updater s.payload) s)


setStatePayload : payload -> State payload -> State payload
setStatePayload payload s =
  { src = s.src
  , offset = s.offset
  , row = s.row
  , col = s.col
  , payload = payload
  }


scopedUpdatePayload : val -> (payload -> val) -> (val -> payload -> payload) -> Parser payload x a -> Parser payload x a
scopedUpdatePayload before afterGet update (Parser parse) =
  Parser <| \s ->
    let
      after =
        afterGet s.payload
    in
    when parse (setStatePayload (update before s.payload) s) is
      Good { pred, value, state } ->
        Good
          { pred = pred
          , value = value
          , state = setStatePayload (update after state.payload) state
          }

      bad ->
        bad


-- POSITION


{-| Just like [`Parser.getPosition`](Parser#getPosition)
-}
getPosition : Parser c x { row: Int, col: Int }
getPosition =
  Parser <| \s -> Good { pred = False, value = { row = s.row, col = s.col }, state = s }


{-| Just like [`Parser.getRow`](Parser#getRow)
-}
getRow : Parser c x Int
getRow =
  Parser <| \s -> Good { pred = False, value = s.row, state = s }


{-| Just like [`Parser.getCol`](Parser#getCol)
-}
getCol : Parser c x Int
getCol =
  Parser <| \s -> Good { pred = False, value = s.col, state = s }


{-| Just like [`Parser.getOffset`](Parser#getOffset)
-}
getOffset : Parser c x Int
getOffset =
  Parser <| \s -> Good { pred = False, value = s.offset, state = s }


{-| Just like [`Parser.getSource`](Parser#getSource)
-}
getSource : Parser c x String
getSource =
  Parser <| \s -> Good { pred = False, value = s.src, state = s }



-- LOW-LEVEL HELPERS


{-| When making a fast parser, you want to avoid allocation as much as
possible. That means you never want to mess with the source string, only
keep track of an offset into that string.

You use `isSubString` like this:

    isSubString "let" offset row col "let x = 4 in x"
        --==> ( newOffset, newRow, newCol )

You are looking for `"let"` at a given `offset`. On failure, the
`newOffset` is `-1`. On success, the `newOffset` is the new offset. With
our `"let"` example, it would be `offset + 3`.

You also provide the current `row` and `col` which do not align with
`offset` in a clean way. For example, when you see a `\n` you are at
`row = row + 1` and `col = 1`. Furthermore, some UTF16 characters are
two words wide, so even if there are no newlines, `offset` and `col`
may not be equal.
-}
isSubString : String -> Int -> Int -> Int -> String -> { newOffset: Int, newRow: Int, newCol: Int }
isSubString smallString offset row col bigString =
  let
    slice =
      String.sliceUnits offset (offset + String.unitLength smallString) bigString

    newlineIndices =
      String.indices "\n" smallString

    sliceLength =
      String.unitLength slice
  in
  { newOffset =
    if smallString == slice then
      offset + sliceLength

    else
      -1
  , newRow = row + Array.length newlineIndices
  , newCol =
    newlineIndices
      |> Array.last
      |> Maybe.map (\newlineIndex -> newlineIndex - offset + 1 + sliceLength)
      |> Maybe.withDefault (col + sliceLength)
  }


{-| Again, when parsing, you want to allocate as little as possible.
So this function lets you say:

    isSubChar isSpace offset "this is the source string"
        --==> newOffset

The `(Char -> Bool)` argument is called a predicate.
The `newOffset` value can be a few different things:

  - `-1` means that the predicate failed
  - `-2` means the predicate succeeded with a `\n`
  - otherwise you will get `offset + 1` or `offset + 2`
    depending on whether the UTF16 character is one or two
    words wide.
-}
isSubChar : (Char -> Bool) -> Int -> String -> Int
isSubChar pred offset str =
  when String.getUnit offset str is
    Nothing ->
      -1

    Just unit ->
      if Bitwise.and (Char.toCode unit) 0xF800 == 0xD800 then
        when String.popFirst (String.sliceUnits offset (offset + 2) str) is
          Just { first = uniChar } ->
            if pred unit then
              offset + 2

            else
              -1

          Nothing ->
            -1

      else
        if pred unit then
          if unit == '\n' then
            -2

          else
            offset + 1

        else
          -1


{-| Find a substring after a given offset.

    findSubString "42" offset row col "Is 42 the answer?"
        --==> (newOffset, newRow, newCol)

If `offset = 0` we would get `(3, 1, 4)`
If `offset = 7` we would get `(-1, 1, 18)`
-}
findSubString : String -> Int -> Int -> Int -> String -> { newOffset: Int, newRow: Int, newCol: Int }
findSubString smallString offset row col bigString =
  let
    slice =
      String.sliceUnits offset (String.unitLength bigString) bigString

    sliceLength =
      String.unitLength slice

    newlines =
      String.indices "\n" slice
  in
  when String.firstIndexOf smallString slice is
    Just idx ->
      let
        relevantNewlines =
          Array.keepIf (\newlineIdx -> newlineIdx < idx) newlines
      in
      { newOffset = offset + idx
      , newRow = row + Array.length relevantNewlines
      , newCol =
        relevantNewlines
          |> Array.last
          |> Maybe.map (\lastNewlineIdx -> lastNewlineIdx - offset + 1)
          |> Maybe.withDefault (col + sliceLength)
      }

    Nothing ->
      { newOffset = -1
      , newRow = row + Array.length newlines
      , newCol =
        newlines
          |> Array.last
          |> Maybe.map (\lastNewlineIdx -> lastNewlineIdx - offset + 1 + sliceLength)
          |> Maybe.withDefault (col + sliceLength)
      }



-- VARIABLES


{-| Just like [`Parser.variable`](Parser#variable) except you specify the
problem yourself.
-}
variable :
  { start : Char -> Bool
  , inner : Char -> Bool
  , expecting : x
  }
  -> Parser c x String
variable i =
  Parser <| \s ->
    let
      firstOffset =
        isSubChar i.start s.offset s.src
    in
    if firstOffset == -1 then
      Bad { pred = False, bag = fromState s i.expecting }
    else
      let
        s1 =
          if firstOffset == -2 then
            varHelp i.inner (s.offset + 1) (s.row + 1) 1 s.src s.payload
          else
            varHelp i.inner firstOffset s.row (s.col + 1) s.src s.payload

        name =
          String.sliceUnits s.offset s1.offset s.src
      in
      Good { pred = True, value = name, state = s1 }


varHelp : (Char -> Bool) -> Int -> Int -> Int -> String -> payload -> State payload
varHelp isGood offset row col src payload =
  let
    newOffset = isSubChar isGood offset src
  in
  if newOffset == -1 then
    { src = src
    , offset = offset
    , payload = payload
    , row = row
    , col = col
    }

  else if newOffset == -2 then
    varHelp isGood (offset + 1) (row + 1) 1 src payload

  else
    varHelp isGood newOffset row (col + 1) src payload



-- SEQUENCES


{-| Contains a string that we expect to chomp and
the problem we'll return in case the parser fails.
-}
type alias Token x =
  { string : String
  , expecting : x
  }


{-| Just like [`Parser.sequence`](Parser#sequence) except with `Token` records for
the start, separator, and end. That way you can specify your custom type of
problem for when something is not found.
-}
sequence
  : { start : Token x
    , separator : Token x
    , end : Token x
    , spaces : Parser c x {}
    , item : Parser c x a
    , trailing : Trailing
    }
  -> Parser c x (Array a)
sequence i =
  revSkip (token i.start.string i.start.expecting) <|
    revSkip i.spaces <|
      sequenceEnd
        (token i.end.string i.end.expecting)
        i.spaces
        i.item
        (token i.separator.string i.separator.expecting)
        i.trailing


{-| Whatâ€™s the deal with trailing commas? Are they `Forbidden`?
Are they `Optional`? Are they `Mandatory`? Welcome to [shapes
club](https://poorlydrawnlines.com/comic/shapes-club/)!
-}
type Trailing = Forbidden | Optional | Mandatory


revSkip : Parser c x ignore -> Parser c x keep -> Parser c x keep
revSkip iParser kParser =
  map2 revAlways iParser kParser


revAlways : a -> b -> b
revAlways _ b =
  b


sequenceEnd : Parser c x {} -> Parser c x {} -> Parser c x a -> Parser c x {} -> Trailing -> Parser c x (Array a)
sequenceEnd ender ws parseItem sep trailing =
  let
    chompRest item =
      when trailing is
        Forbidden ->
          loop [item] (sequenceEndForbidden ender ws parseItem sep)

        Optional ->
          loop [item] (sequenceEndOptional ender ws parseItem sep)

        Mandatory ->
          skip ender
            ( revSkip ws <| revSkip sep <| revSkip ws <|
                loop [item] (sequenceEndMandatory ws parseItem sep)
            )
  in
  oneOf
    [ parseItem |> andThen chompRest
    , ender |> map (\_ -> [])
    ]


sequenceEndForbidden : Parser c x {} -> Parser c x {} -> Parser c x a -> Parser c x {} -> Array a -> Parser c x (Step (Array a) (Array a))
sequenceEndForbidden ender ws parseItem sep items =
  revSkip ws <|
    oneOf
      [ revSkip sep <| revSkip ws <| map (\item -> Loop (Array.pushLast item items)) parseItem
      , ender |> map (\_ -> Done items )
      ]


sequenceEndOptional : Parser c x {} -> Parser c x {} -> Parser c x a -> Parser c x {} -> Array a -> Parser c x (Step (Array a) (Array a))
sequenceEndOptional ender ws parseItem sep items =
  let
    parseEnd =
      map (\_ -> Done items) ender
  in
  revSkip ws <|
    oneOf
      [ revSkip sep <| revSkip ws <|
          oneOf
            [ parseItem |> map (\item -> Loop (Array.pushLast item items))
            , parseEnd
            ]
      , parseEnd
      ]


sequenceEndMandatory : Parser c x {} -> Parser c x a -> Parser c x {} -> Array a -> Parser c x (Step (Array a) (Array a))
sequenceEndMandatory ws parseItem sep items =
  oneOf
    [ map (\item -> Loop (Array.pushLast item items)) <|
        skip (skip (skip ws sep) ws) parseItem
    , map (\_ -> Done items) (succeed {})
    ]



-- WHITESPACE


{-| Just like [`Parser.spaces`](Parser#spaces)
-}
spaces : Parser c x {}
spaces =
  chompWhile (\c -> c == ' ' || c == '\n' || c == '\r')


{-| Just like [`Parser.lineComment`](Parser#lineComment) except you provide a
problem in case the parser fails.
-}
lineComment : String -> x -> Parser c x {}
lineComment string expecting =
  skip (chompUntilEndOr "\n") (token string expecting)


{-| Just like [`Parser.multiComment`](Parser#multiComment) except with a
`Token` for the open and close symbols.
-}
multiComment : Token x -> Token x -> Nestable -> Parser c x {}
multiComment open close nestable =
  when nestable is
    NotNestable ->
      skip (chompUntil close.string close.expecting) (token open.string open.expecting)

    Nestable ->
      nestableComment open close


{-| Works just like [`Parser.Nestable`](Parser#Nestable) to help distinguish
between unnestable `/*` `*/` comments like in JS and nestable `{-` `-}`
comments like in Gren.
-}
type Nestable = NotNestable | Nestable


nestableComment : Token x -> Token x -> Parser c x {}
nestableComment ({ string = oStr, expecting = oX } as open) ({ string = cStr, expecting = cX } as close) =
  when String.popFirst oStr is
    Nothing ->
      problem oX

    Just { first = openChar } ->
      when String.popFirst cStr is
        Nothing ->
          problem cX

        Just { first = closeChar } ->
          let
            isNotRelevant char =
              char /= openChar && char /= closeChar

            chompOpen =
              token oStr oX
          in
          skip (nestableHelp isNotRelevant chompOpen (token cStr cX) cX 1) chompOpen


nestableHelp : (Char -> Bool) -> Parser c x {} -> Parser c x {} -> x -> Int -> Parser c x {}
nestableHelp isNotRelevant open close expectingClose nestLevel =
  revSkip (chompWhile isNotRelevant) <|
    oneOf
      [ if nestLevel == 1 then
          close
        else
          close
            |> andThen (\_ -> nestableHelp isNotRelevant open close expectingClose (nestLevel - 1))
      , open
          |> andThen (\_ -> nestableHelp isNotRelevant open close expectingClose (nestLevel + 1))
      , chompIf isChar expectingClose
          |> andThen (\_ -> nestableHelp isNotRelevant open close expectingClose nestLevel)
      ]


isChar : Char -> Bool
isChar char =
  True


-- ERROR RENDERING


{-| Describes how to output the various parts of the error message.
-}
type alias Output out =
    { text : String -> out
    , formatCaret : out -> out
    , newline : out
    , formatContext : out -> out
    , linesOfExtraContext : Int
    }


{-| Describes how to get the context stack from a `DeadEnd` and how to extract expectations information from a problem.
-}
type alias Extract payload problem =
    { deadEndToString : DeadEnd payload problem -> { row : Int, col : Int, context : String }
    , problemToString : problem -> Expected
    }


{-| A problem is often of the form "expected `something`". This type is used to group those together.
-}
type Expected
    = Expected String
    | Other String


type Line a
    = Line (Array a)


{-| Render an array of `DeadEnd`s.

The `String` is the input to the parser.

This returns a list of renderable "pieces", explaining what went wrong.
-}
renderDeadEnds :
    Output out
    -> Extract payload problem
    -> String
    -> Array (DeadEnd payload problem)
    -> Array out
renderDeadEnds output extract src deadEnds =
    let
        lines =
            src
                |> String.split "\n"
                |> Array.indexedMap (\i l -> { row = i + 1, string = l })
    in
    deadEnds
        |> gatherEqualsBy (\{ row, col } -> [ row, col ])
        |> Array.mapAndFlatten (\line -> deadEndToString output extract lines (Array.sortBy .col line))
        |> Array.intersperse (Line [ output.newline ])
        |> Array.mapAndFlatten (\(Line l) -> l)


gatherEqualsBy : (a -> b) -> Array a -> Array (Array a)
gatherEqualsBy fn array =
  let
    helper gathered scattered =
      when Array.popFirst scattered is
        Nothing ->
          gathered  

        Just { first, rest } ->
          let
            firstComp =
              fn first

            { trues = group, falses = stillScattered } =
              Array.partition (\a -> firstComp == fn a) scattered
          in
          helper (Array.pushLast group gathered) stillScattered
  in
  helper [] array


deadEndToString :
    Output out
    -> Extract payload problem
    -> Array { row : Int, string : String }
    -> Array (DeadEnd payload problem)
    -> Array (Line out)
deadEndToString output extract lines deadEnds =
    let
        grouped : Array { row : Int, col : Int, context : String, problems : Array problem }
        grouped =
            deadEnds
                |> gatherEqualsBy extract.deadEndToString
                |> Array.map
                    (\group ->
                      when Array.popFirst group is
                        Nothing ->
                          -- Shouldn't happen :/
                          { row = 1
                          , col = 1
                          , context = ""
                          , problems = Array.map .problem group
                          }

                        Just { first, rest } ->
                          let
                            extractedFirst =
                              extract.deadEndToString first
                          in
                          { row = extractedFirst.row
                          , col = extractedFirst.col
                          , context = extractedFirst.context
                          , problems = Array.map .problem group
                          }
                    )

        sourceFragment : Array (Line out)
        sourceFragment =
          when Array.popFirst deadEnds is
            Nothing ->
              []

            Just { first } ->
              formatSourceFragment output { row = first.row, col = first.col } lines

        groupToString :
            { row : Int, col : Int, context : String, problems : Array problem }
            -> Array (Line out)
        groupToString { context, problems } =
            let
                { expected, other } =
                    Array.foldl
                        (\prob acc ->
                            when extract.problemToString prob is
                                Expected e ->
                                    { expected = Set.set e acc.expected, other = acc.other }

                                Other o ->
                                    { expected = acc.expected, other = Set.set o acc.other }
                        )
                        { expected = Set.empty, other = Set.empty }
                        problems

                groupedExpected : Array String
                groupedExpected =
                    when Set.toArray expected is
                        [] ->
                            []

                        [ x ] ->
                            [ "Expecting " ++ x ]

                        rest ->
                            [ "Expecting one of "
                                ++ String.join ", " rest
                            ]

                problemsLines : Array (Line out)
                problemsLines =
                    (groupedExpected ++ Set.toArray other)
                        |> Array.sort
                        |> Array.map (\l -> Line [ output.text ("  " ++ l) ])
            in
            if String.isEmpty context then
                problemsLines

            else
              Array.pushLast
                ( Line
                    [ output.text "- "
                    , output.formatContext (output.text context)
                    , output.text ":"
                    ]
                )
                problemsLines
    in
    Array.flatten
      [ sourceFragment
      , [ Line [ output.text "" ] ]
      , Array.mapAndFlatten groupToString grouped
      ]


formatSourceFragment : Output a -> { row : Int, col : Int } -> Array { row : Int, string : String } -> Array (Line a)
formatSourceFragment output head lines =
    let
        line : { row : Int, string : String }
        line =
            lines
                |> Array.dropFirst (head.row - 1)
                |> Array.first
                |> Maybe.withDefault { row = head.row, string = "" }

        before : Array { row : Int, string : String }
        before =
            lines
                |> Array.dropFirst (head.row - output.linesOfExtraContext)
                |> Array.takeFirst output.linesOfExtraContext
                |> Array.keepIf (\{ row } -> row < head.row)

        after : Array { row : Int, string : String }
        after =
            lines
                |> Array.dropFirst head.row
                |> Array.takeFirst output.linesOfExtraContext

        formatLine : { row : Int, string : String } -> Line a
        formatLine { row, string = l } =
            Line
                [ output.text
                    (String.padLeft numLength ' ' (String.fromInt row)
                        ++ "| "
                        ++ l
                    )
                ]

        numLength : Int
        numLength =
            after
                |> Array.last
                |> Maybe.map (\{ row } -> row)
                |> Maybe.withDefault head.row
                |> String.fromInt
                |> String.count

        caret : Line a
        caret =
            Line
                [ output.text (String.repeat (numLength + head.col + 1) " ")
                , output.formatCaret (output.text "^")
                ]
    in
    Array.map formatLine before
        ++ [ formatLine line, caret ]
        ++ Array.map formatLine after
